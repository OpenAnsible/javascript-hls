<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" />
    <title>MediaSource API Demo</title>
</head>

<body>

<h3>Appending .webm video chunks using the Media Source API</h3>

<section>
    <video controls autoplay width="320" height="240"></video>
    <pre id="log"></pre>
</section>


<script>
/**

bash command:
    
    cd javascript-hls;
    python -m SimpleHTTPServer 8000
    # Chrome Only!
    open "http://127.0.0.1:8000/media_source_demo.html"


**/
window.MediaSource = window.MediaSource || window.WebKitMediaSource;

var webm_file_url = "/assets/video/test.webm";
var video = document.querySelector('video');
var mediaSource = new MediaSource();
var sourceBuffer = null;
var chunks = [];

video.src = window.URL.createObjectURL(mediaSource);


function fetch(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.send();

    var NUM_CHUNKS = 5;
    var chunkSize  = 0;
    var file = null;

    var read_chunk = function (i){
        var reader = new FileReader();
        reader.onload = function(e) {
            console.log('appending chunk:' + i);
            sourceBuffer.appendBuffer(new Uint8Array(e.target.result));
            if (i == NUM_CHUNKS - 1) {
                try{
                    mediaSource.endOfStream();
                }catch(e){

                }
            } else {
                if (video.paused) {
                    video.play();
                }
                read_chunk(i+1);
            }
        };
        var startByte = chunkSize * i;
        var chunk = file.slice(startByte, startByte + chunkSize);
        reader.readAsArrayBuffer(chunk);
    };

    xhr.onload = function(e) {
        if (xhr.status != 200) {
            window.alert("Unexpected status code " + xhr.status + " for " + url);
            return false;
        }
        // callback(new Uint8Array(xhr.response));
        file = new Blob([xhr.response], {type: 'video/webm'});
        chunkSize = Math.ceil(file.size / NUM_CHUNKS);
        console.log('chunkSize:' + chunkSize + ', totalSize:' + file.size);
        
        read_chunk(0);
    };
}


var onChunk = function (){

};

var onSourceOpen = function (e){
    console.log('mediaSource readyState: ' + this.readyState);
    sourceBuffer = mediaSource.addSourceBuffer('video/webm; codecs="vorbis,vp8"');
    var callback = function (_chunks){
        console.log(_chunks);
        sourceBuffer.appendBuffer(_chunks[0]);
        sourceBuffer.appendBuffer(_chunks[1]);
        sourceBuffer.appendBuffer(_chunks[2]);
        sourceBuffer.appendBuffer(_chunks[3]);
        sourceBuffer.appendBuffer(_chunks[4]);
        return;
        _chunks.forEach(function (_chunk, i){
            console.log('appending chunk:' + i);
            sourceBuffer.appendBuffer(_chunk);
            if (i == _chunks.length - 1) {
                mediaSource.endOfStream();
            } else {
                if (video.paused) {
                    video.play();
                }
            }
        });
    };
    fetch(webm_file_url, callback);
};


if (!!!window.MediaSource) {
    window.alert('MediaSource API is not available');
} else {
    mediaSource.addEventListener('sourceopen', onSourceOpen, false);
    mediaSource.addEventListener('webkitsourceopen', onSourceOpen, false);

    mediaSource.addEventListener('webkitsourceended', function(e) {
        console.log('mediaSource readyState: ' + this.readyState);
    }, false);
}
</script>


</body>
</html>